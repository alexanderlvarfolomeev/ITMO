# Тесты к курсу «Парадигмы программирования»

## Весенний семестр

### Домашнее задание 11. Ассоциативные массивы на Prolog (Associative array in Prolog)
----

1.	Реализуйте ассоциативный массив (map).
2.	**Простой вариант**. Ассоциативный массив на упорядоченном списке пар ключ-значение.

Разработайте правила:

* `map_get(ListMap, Key, Value)`, проверяющее, что дерево содержит заданную пару ключ-значение.
* `map_put(ListMap, Key, Value, Result)`, добавляющее пару ключ-значение в дерево, или заменяющее текущее значение для ключа;
* `map_remove(ListMap, Key, Result)`, удаляющее отображение для ключа.
	
Правила не должны анализировать хвост списка, если в нем точно нет необходимого ключа.

3.	**Сложный вариант**. Ассоциативный массив на двоичном дереве.

Разработайте правила:

* `tree_build(ListMap, TreeMap)`, строящее дерево из упорядоченного набора пар ключ-значение;
* `map_get(TreeMap, Key, Value)`.
	
Для решения можно реализовать любое дерево поиска логарифмической высоты.

4.	**Бонусный вариант**. Дополнительно разработайте правила:

* `map_put(TreeMap, Key, Value, Result)`;
* `map_remove(TreeMap, Key, Result)`.
	
Модификации
 * *Простая*
    * Код должен находиться в файле `sorted-list-map.pl`.
        * Запускать c аргументом `sorted`
 * *Сложная*
    * Код должен находиться в файле `tree-map.pl`.
        * Запускать c аргументом `hard` или `bonus`
 * *Replace*
    * Добавьте правило `map_replace(Map, Key, Value, Result)`,
        заменяющего значения ключа на указанное, если ключ присутствует.
    * Исходный код тестов:
 * *Size*
    * Добавьте правило `map_size(Map, Size)`, возвращающее размер дерева


### Домашнее задание 10. Комбинаторные парсеры (Combinator Parsers)
----

1.	**Простой вариант**. Реализуйте функцию `(parseObjectSuffix "expression")`, разбирающую выражения, записанные в суффиксной форме, и функцию `toStringSuffix`, возвращающую строковое представление выражения в этой форме. Например,
```
(toStringSuffix (parseObjectSuffix "( ( 2 x * ) 3 - )"))
```
должно возвращать `((2 x *) 3 -)`.

2.	**Сложный вариант**. Реализуйте функцию `(parseObjectInfix "expression")`, разбирающую выражения, записанные в инфиксной форме, и функцию `toStringInfix`, возвращающую строковое представление выражения в этой форме. Например,
```
(toStringInfix (parseObjectInfix "2 * x - 3"))
```
должно возвращать `((2 * x) - 3)`.

3.	Функции разбора должны базироваться на библиотеке комбинаторов, разработанной на лекции.

Модификации
 * *Базовая*
    * Код должен находиться в файле `expression.clj`.
        * Запускать c аргументом `easy` или `hard`
 * *Variables*. Дополнительно реализовать поддержку:
    * Переменных, состоящих из произвольного количества букв `XYZ` в любом регистре
        * Настоящее имя переменной определяется первой буквой ее имени
 * *PowLog*. Дополнительно реализовать поддержку:
    * Бинарных правоассоциативных операций максимального приоритета:
        * `Pow` (`**`) – возведения в степень:
            `4 ** 3 ** 2` равно `4 ** (3 ** 2)` равно 262144
        * `Log` (`//`) – взятия логарифма:
            `8 // 9 // 3` равно `8 // (9 // 3)` равно 3
 * *Bitwise*. Дополнительно реализовать поддержку:
    * Побитовых операций
        * `And` (`&`) – и: `5 & 6` равно 4
        * `Or` (`|`) - или: `5 & 6` равно 7
        * `Xor` (`^`) - исключающее: `5 ^ 6` примерно равно 1.66881E-308
        * для реализации операций используйте
            [doubleToLongBits](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Double.html#doubleToLongBits(double))
            и [longBitsToDouble](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Double.html#longBitsToDouble(long))
        * операции по увеличиению приоритета: `^`, `|`, `&`, `+` и `-`, `*` и `/`


### Домашнее задание 9. Объектные выражения на Clojure (Object Expressions Clojure)
----

1.	Разработайте конструкторы `Constant`, `Variable`, `Add`, `Subtract`, `Multiply` и `Divide` для представления выражений с одной переменной.
	1.	Пример описания выражения `2x-3`:
	```
					(def expr
						(Subtract
							(Multiply
								(Constant 2)
								(Variable "x"))
						(Const 3)))
	```
	2.	Функция `(evaluate expression vars)` должна производить вычисление выражения expression для значений переменных, заданных отображением `vars`. Например, `(evaluate expr {"x" 2})` должно быть равно 1.
	3.	Функция `(toString expression)` должна выдавать запись выражения в стандартной для Clojure форме.
	4.	Функция `(parseObject "expression")` должна разбирать выражения, записанные в стандартной для Clojure форме. Например,
	```
				(parseObject "(- (* 2 x) 3)")
	```
	должно быть эквивалентно expr.

	5.	Функция `(diff expression "variable")` должена возвращать выражение, представляющее производную исходного выражения по заданой пермененной. Например, `(diff expression "x")` должен возвращать выражение, эквивалентное `(Constant 2)`, при этом выражения `(Subtract (Const 2) (Const 0))` и
	```
	(Subtract
	(Add
		(Multiply (Const 0) (Variable "x"))
		(Multiply (Const 2) (Const 1)))
	(Const 0))
	```                    
	так же будут считаться правильным ответом.

2.	**Усложненный вариант**. Констуркторы `Add`, `Subtract`, `Multiply` и `Divide` должны принимать произвольное число аргументов. Разборщик так же должен допускать произвольное число аргументов для `+`, `-`, `*`, `/`.
3.	При выполнение задания можно использовать любой способ преставления объектов.

Модификации
 * *Базовая*
    * Код должен находиться в файле `expression.clj`.
        * Запускать c аргументом `easy` или `hard`
 * *SinhCosh*. Дополнительно реализовать поддержку:
    * унарных операций:
        * `Sinh` (`sinh`) – гиперболический синус, `(sinh 3)` немного больше 10;
        * `Cosh` (`cosh`) – гиперболический косинус, `(cosh 3)` немного меньше 10.
 * *SquareSqrt*. Дополнительно реализовать поддержку:
    * унарных операций:
        * `Square` (`square`) – возведение в квадрат, `(square 3)` равно 9;
        * `Sqrt` (`sqrt`) – извлечение квадратного корня из модуля аргумента, `(sqrt -9)` равно 3.


### Домашнее задание 8. Функциональные выражения на Clojure (Functional Expressions Clojure)
----

1. 	Разработайте функции `constant`, `variable`, `add`, `subtract`, `multiply` и `divide` для представления арифметических выражений.
Пример описания выражения `2x-3`:
```
                        (def expr 
                          (subtract
                            (multiply 
                              (constant 2) 
                              (variable "x")) 
                            (constant 3)))
```
Выражение должно быть функцией, возвращающей значение выражение при подстановке элементов, заданных отображением. Например, `(expr {"x" 2})` должно быть равно `1`.  
2. Разработайте разборщик выражений, читающий выражения в стандартной для Clojure форме. Например,
```
(parseFunction "(- (* 2 x) 3)")
```
должно быть эквивалентно `expr`.  
3. **Усложненный вариант.** Функции `add`, `subtract`, `multiply` и должны принимать произвольное число аргументов. Разборщик так же должен допускать произвольное число аргументов для `+`, `-`, `*`.  
4. При выполнение задания следует обратить внимание на:
	* Выделение общего кода для операций.

Модификации
 * *Базовая*
    * Код должен находиться в файле `expression.clj`.
        * Запускать c аргументом `easy` или `hard`
 * *SquareSqrt*. Дополнительно реализовать поддержку:
    * унарных операций:
        * `square` (`square`) – возведение в квадрат, `(square 3)` равно 9;
        * `sqrt` (`sqrt`) – извлечение квадратного корня из модуля аргумента, `(sqrt -9)` равно 3.
 * *MinMax*. Дополнительно реализовать поддержку:
    * операций:
        * `min` (`min`) – минимум, `(min 1 2 6)` равно 1;
        * `max` (`max`) – максимум, `(min 1 2 6)` равно 6;


### Домашнее задание 7. Линейная алгебра на Clojure (Linear Algebra Clojure)
----

1. Разработайте функции для работы с объектами линейной алгебры, которые представляются следующим образом:
	* скаляры – числа
	* векторы – векторы чисел;
	* матрицы – векторы векторов чисел.
2. Функции над векторами:
	* `v+/v-/v\*` – покоординатное сложение/вычитание/умножение;
	* `scalar/vect` – скалярное/векторное произведение;
	* `v\*s` – умножение на скаляр.
3. Функции над матрицами:
	* `m+/m-/m\*` – поэлементное сложение/вычитание/умножение;
	* `m\*s` – умножение на скаляр;
	* `m\*v` – умножение на вектор;
	* `m\*m` – матричное умножение;
	* `transpose` – траспонирование;
4. **Усложненный вариант.**
	* Ко всем функциям должны быть указаны контракты. Например, нельзя складывать вектора разной длины.
	* Все функции должны поддерживать произвольное число аргументов. Например `(v+ [1 2] [3 4] [5 6])` должно быть равно `[9 12]`.
5. При выполнение задания следует обратить внимание на:
	* Применение функций высшего порядка.
	* Выделение общего кода для операций.

Модификации
 * *Базовая*
    * Код должен находиться в файле `linear.clj`.
 * *Tensor*
    * Назовем _тензором_ многомерную прямоугольную таблицу чисел.
    * Добавьте операции поэлементного сложения (`t+`),
        вычитания (`t-`) и умножения (`t*`) тензоров.
        Например, `(s+ [[1 2] [3 4]] [[5 6] [7 8]])` должно быть равно `[[6 8] [10 12]]`.


### Домашнее задание 6. Обработка ошибок на JavaScript (Exceptions JavaScript)
----

1. Добавьте в предыдущее домашнее задание функцию `parsePrefix(string)`, разбирающую выражения, задаваемые записью вида `(- (* 2 x) 3)`. Если разбираемое выражение некорректно, метод `parsePrefix` должен бросать человеко-читаемое сообщение об ошибке.
2. Добавьте в предыдущее домашнее задание метод `prefix()`, выдающий выражение в формате, ожидаемом функцией `parsePrefix`.
3. При выполнение задания следует обратить внимание на:
	* Применение инкапсуляции.
	* Выделение общего кода для бинарных операций.
	* Обработку ошибок.
	* Минимизацию необходимой памяти.

Модификации
 * *Базовая*
    * Код должен находиться в файле `objectExpression.js`.
 * *PrefixSumexpSoftmax*. Дополнительно реализовать поддержку:
    * операций произвольного числа аргументов:
        * `Sumexp` (`sumexp`) — сумма экспонент, `(8 8 9)` примерно равно 14065;
        * `Softmax` (`softmax`) — softmax первого аргумента, `(softmax 1 2 3)` примерно равно 9;
 * *PostfixSumexpSoftmax*. Дополнительно реализовать поддержку:
    * выражений в постфиксной записи: `(2 3 +)` равно 5
    * унарных операций:
        * `Sumexp` (`sumexp`) — сумма экспонент, `(8 8 9 sumexp)` примерно равно 14065;
 * *PrefixSumAvg*. Дополнительно реализовать поддержку:
    * операций произвольного числа аргументов:
        * `Sum` (`sum`) — сумма, `(sum 1 2 3)` равно 6;
        * `Avg` (`avg`) — арифметическое среднее, `(avg 1 2 3)` равно 2;
 * *PostfixSumAvg*. Дополнительно реализовать поддержку:
    * выражений в постфиксной записи: `(2 3 +)` равно 5
    * унарных операций:
        * `Sum` (`sum`) — сумма, `(1 2 3 sum)` равно 6;
        * `Avg` (`avg`) — арифметическое среднее, `(1 2 3 avg)` равно 2;


### Домашнее задание 5. Объектные выражения на JavaScript (Object Expressions JavaScript)
----

1. Разработайте классы Const, Variable, Add, Subtract, Multiply, Divide, Negate для представления выражений с одной переменной.
	* Пример описания выражения `2x-3`:
	```
                        let expr = new Subtract(
                            new Multiply(
                                new Const(2),
                                new Variable("x")
                            ),
                            new Const(3)
                        );
    ```                
	* Метод `evaluate(x)` должен производить вычисления вида: При вычислении такого выражения вместо каждой переменной подставляется значение x, переданное в качестве параметра функции evaluate (на данном этапе имена переменных игнорируются). Таким образом, результатом вычисления приведенного примера должно стать число 7.
	* Метод `toString()` должен выдавать запись выражения в обратной польской записи. Например, `expr.toString()` должен выдавать `2 x \* 3 \-`.
2. **Усложненный вариант.**
Метод `diff("x")` должен возвращать выражение, представляющее производную исходного выражения по переменной `x`. Например, `expr.diff("x")` должен возвращать выражение, эквивалентное `new Const(2)` (выражения `new Subtract(new Const(2), new Const(0))` и
    ```                
					new Subtract(
                        new Add(
                            new Multiply(new Const(0), new Variable("x")),
                            new Multiply(new Const(2), new Const(1))
                        )
                        new Const(0)
                    )
    ```             
так же будут считаться правильным ответом).
Функция `parse` должна выдавать разобранное объектное выражение.

3. Бонусный вариант. Требуется написать метод simplify(), производящий вычисления константных выражений. Например,
```
parse("x x 2 - * 1 *").diff("x").simplify().toString()
```
должно возвращать «`x x 2 - +`».
4. При выполнение задания следует обратить внимание на:  
	* Применение инкапсуляции.  
	* Выделение общего кода для операций.  

Модификации
 * *Базовая*
    * Код должен находиться в файле `objectExpression.js`.
 * *ArcTan*. Дополнительно реализовать поддержку:
    * функций:
        * `ArcTan` (`atan`) — арктангенс, `1256 atan` примерно равно 1.57;
        * `ArcTan2` (`atan2`) — арктангенс, `841 540 atan2` примерно равно 1;
 * *SinhCosh*. Дополнительно реализовать поддержку:
    * унарных функций:
        * `Sinh` (`sinh`) — гиперболический синус, `3 sinh` немного больше 10;
        * `Cosh` (`cosh`) — гиперболический косинус, `3 cosh` немного меньше 10;


### Домашнее задание 4. Функциональные выражения на JavaScript (Functional Expressions)
----

1. Разработайте функции cnst, variable, add, subtract, multiply, divide, negate для вычисления выражений с одной переменной.  
2. Функции должны позволять производить вычисления вида:
```
                let expr = subtract(
                    multiply(
                        cnst(2),
                        variable("x")
                    ),
                    cnst(3)
                );
                println(expr(5));
```            
При вычислении такого выражения вместо каждой переменной подставляется значение, переданное в качестве параметра функции expr (на данном этапе имена переменных игнорируются). Таким образом, результатом вычисления приведенного примера должно стать число `7`.  
3. Тестовая программа должна вычислять выражение x2−2x+1, для x от 0 до 10.  
4. **Усложненный вариант.** Требуется написать функцию parse, осуществляющую разбор выражений, записанных в [обратной польской записи](https://ru.wikipedia.org/wiki/Обратная_польская_запись). Например, результатом
```
parse("x x 2 - * x * 1 +")(5)
```
должно быть число 76.
5. При выполнение задания следует обратить внимание на:
	* Применение функций высшего порядка.
	* Выделение общего кода для бинарных операций.

Модификации
 * *Базовая*
    * Код должен находиться в файле `functionalExpression.js`.
 * *OneIffAbs*. Дополнительно реализовать поддержку:
    * переменных: `y`, `z`;
    * констант:
        * `one` — 1;
        * `two` — 2;
    * операций:
        * `abs` — абсолютное значение, `-2 abs` равно 2;
        * `iff` — условный выбор:
            если первый аргумент неотрицательный,
            вернуть второй аргумент,
            иначе вернуть первый третий аргумент.
            * `iff one two 3` равно 2
            * `iff -1 -2 -3` равно -3
            * `iff 0 one two` равно 1;


### Домашнее задание 3. Вычисление в различных типах (Generic)
----

1. Добавьте в программу вычисляющую выражения поддержку различных типов.
	* Первым аргументом командной строки программа должна принимать указание на тип, в котором будут производится вычисления:  
	**Опция	Тип**  
	-i	int  
	-d	double  
	-bi	[BigInteger](http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html)  
	* Реализация не должна содержать [непроверяемых преобразований типов](http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.9).
	* Реализация не должна использовать аннотацию [@SuppressWarnings](http://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.6.4.5).
2. При выполнении задания следует обратить внимание на легкость добавления новых типов и операциий.

Модификации
 * *Базовая*
    * Класс `GenericTabulator` должен реализовывать интерфейс
      [Tabulator](Java/Generic/expression/generic/Tabulator.java) и
      сроить трехмерную таблицу значений заданного выражения.
        * `mode` — режим вычислений:
           * `i` — вычисления в `int` с проверкой на переполнение;
           * `d` — вычисления в `double` без проверки на переполнение;
           * `bi` — вычисления в `BigInteger`.
        * `expression` — выражение, для которого надо построить таблицу;
        * `x1`, `x2` — минимальное и максимальное значения переменной `x` (включительно)
        * `y1`, `y2`, `z1`, `z2` — аналогично для `y` и `z`.
        * Результат: элемент `result[i][j][k]` должен содержать
          значение выражения для `x = x1 + i`, `y = y1 + j`, `z = z1 + k`.
          Если значение не определено (например, по причине переполнения),
          то соответствующий элемент должен быть равен `null`.
 * *AsmUfb*
    * Дополнительно реализовать унарные операции:
        * `abs` — модуль числа, `abs -5` равно 5;
        * `square` — возведение в квадрат, `square 5` равно 25.
    * Дополнительно реализовать бинарную операцию (максимальный приоритет):
        * `mod` — взятие по модулю, приоритет как у умножения (`1 + 5 mod 3` равно `1 + (5 mod 3)` равно `3`).
    * Дополнительно реализовать поддержку режимов:
        * `u` — вычисления в `int` без проверки на переполнение;
        * `f` — вычисления в `float` без проверки на переполнение;
        * `b` — вычисления в `byte` без проверки на переполнение.
 * *Ls*
    * Дополнительно реализовать поддержку режимов:
        * `l` — вычисления в `long` без проверки на переполнение;
        * `s` — вычисления в `short` без проверки на переполнение.


### Домашнее задание 2. Markdown to HTML (Markdown2Html)
----

1. Разработайте конвертер из Markdown-разметки в HTML.
2. Конвертер должен поддерживать следующие возможности:
	* Абзацы текста разделяются пустыми строками.  
	* Элементы строчной разметки: выделение (\* или \_), сильное выделение (\*\* или \_\_), зачеркивание (\-\-), код (\`)  
	* Заголовки (# \* уровень заголовка)  
3. Конвертер должен называться Md2Html и принимать два аргумента: название входного файла с Markdown-разметкой и название выходного файла c HTML-разметкой. Оба файла должны иметь кодировку UTF-8.
4. Пример
* Входной файл
```	
			# Заголовок первого уровня

			## Второго

			### Третьего ## уровня

			#### Четвертого
			# Все еще четвертого

			Этот абзац текста,
			содержит две строки.

				# Может показаться, что это заголовок.
			Но нет, это абзац начинающийся с `#`.

			#И это не заголовок.

			###### Заголовки могут быть многострочными
			(и с пропуском заголовков предыдущих уровней)

			Мы все любим *выделять* текст _разными_ способами.
			**Сильное выделение**, используется гораздо реже,
			но __почему бы и нет__?
			Немного --зачеркивания-- еще ни кому не вредило.
			Код представляется элементом `code`.

			Обратите внимание, как экранируются специальные
			HTML-символы, такие как `<`, `>` и `&`.

			Знаете ли вы, что в Markdown, одиночные * и _
			не означают выделение?
			Они так же могут быть заэкранированы
			при помощи обратного слэша: \*.



			Лишние пустые строки должны игнорироваться.

			Любите ли вы *вложеные __выделения__* так,
			как __--люблю--__ их я?
```
* Выходной файл
```
			<h1>Заголовок первого уровня</h1>
			<h2>Второго</h2>
			<h3>Третьего ## уровня</h3>
			<h4>Четвертого
			\# Все еще четвертого</h4>
			<p>Этот абзац текста,
			содержит две строки.</p>
			<p>    # Может показаться, что это заголовок.
			Но нет, это абзац начинающийся с <code>#</code>.</p>
			<p>#И это не заголовок.</p>
			<h6>Заголовки могут быть многострочными
			(и с пропуском заголовков предыдущих уровней)</h6>
			<p>Мы все любим <em>выделять</em> текст <em>разными</em> способами.
			<strong>Сильное выделение</strong>, используется гораздо реже,
			но <strong>почему бы и нет</strong>?
			Немного <s>зачеркивания</s> еще ни кому не вредило.
			Код представляется элементом <code>code</code>.</p>
			<p>Обратите внимание, как экранируются специальные
			HTML-символы, такие как <code>&lt;</code>, <code>&gt;</code> и <code>&amp;</code>.</p>
			<p>Знаете ли вы, что в Markdown, одиночные * и _
			не означают выделение?
			Они так же могут быть заэкранированы
			при помощи обратного слэша: *.</p>
			<p>Лишние пустые строки должны игнорироваться.</p>
			<p>Любите ли вы <em>вложеные <strong>выделения</strong></em> так,
			как <strong><s>люблю</s></strong> их я?</p>
```
* Реальная разметка

# Заголовок первого уровня

## Второго

### Третьего ## уровня

#### Четвертого
# Все еще четвертого

Этот абзац текста,
содержит две строки.

	# Может показаться, что это заголовок. Но нет, это абзац начинающийся с `#`.

#И это не заголовок.

###### Заголовки могут быть многострочными(и с пропуском заголовков предыдущих уровней)

Мы все любим *выделять* текст _разными_ способами.
**Сильное выделение**, используется гораздо реже,
но __почему бы и нет__?
Немного --зачеркивания-- еще ни кому не вредило.
Код представляется элементом `code`.

Обратите внимание, как экранируются специальные
HTML-символы, такие как `<`, `>` и `&`.

Знаете ли вы, что в Markdown, одиночные * и _
не означают выделение?
Они так же могут быть заэкранированы
при помощи обратного слэша: \*.



Лишние пустые строки должны игнорироваться.

Любите ли вы *вложеные __выделения__* так,
как __--люблю--__ их я?


Модификация
 * *Mark*
    * Добавьте поддержку `~выделения цветом~`: `<mark>выделения цветом</mark>`


### Домашнее задание 1. Обработка ошибок (Exceptions)
----

1. Добавьте в программу вычисляющую выражения обработку ошибок, в том числе:
	* ошибки разбора выражений;
	* ошибки вычисления выражений.
2. Для выражения `1000000*x*x*x*x*x/(x-1)` вывод программы должен иметь следующий вид:
```
                x       f
                0       0
                1       division by zero
                2       32000000
                3       121500000
                4       341333333
                5       overflow
                6       overflow
                7       overflow
                8       overflow
                9       overflow
                10      overflow
```
Результат division by zero (overflow) означает, что в процессе вычисления произошло деление на ноль (переполнение).
3. При выполнении задания следует обратить внимание на дизайн и обработку исключений.
4. Человеко-читаемые сообщения об ошибках должны выводится на консоль.
5. Программа не должна «вылетать» с исключениями (как стандартными, так и добавленными).

Модификации
 * *Базовая*
    * Класс `ExpressionParser` должен реализовывать интерфейс
        [Parser](Java/Exceptions/expression/exceptions/Parser.java)
    * Классы `CheckedAdd`, `CheckedSubtract`, `CheckedMultiply`,
        `CheckedDivide` и `CheckedNegate` должны реализовывать интерфейс
        [TripleExpression](Java/Exceptions/expression/TripleExpression.java)
    * Нельзя использовать типы `long` и `double`
    * Нельзя использовать методы классов `Math` и `StrictMath`
 * *HighLow*
    * Дополнительно реализовать унарные операции:
        * `high` — значение, у которого оставлен только самый старший
          установленный бит `high -4` равно `Integer.MIN_VALUE`;
        * `low` — значение, у которого оставлен только самый младший
          установленный бит `low 18` равно `2`.

## Осенний семестр

### Домашнее задание 12. Обработка ошибок (Exceptions)
----

1. Добавьте в программу вычисляющую выражения обработку ошибок, в том числе:
	* ошибки разбора выражений;
	* ошибки вычисления выражений.
2. Для выражения `1000000*x*x*x*x*x/(x-1)` вывод программы должен иметь следующий вид:
```
                x       f
                0       0
                1       division by zero
                2       32000000
                3       121500000
                4       341333333
                5       overflow
                6       overflow
                7       overflow
                8       overflow
                9       overflow
                10      overflow
```
Результат division by zero (overflow) означает, что в процессе вычисления произошло деление на ноль (переполнение).
3. При выполнении задания следует обратить внимание на дизайн и обработку исключений.
4. Человеко-читаемые сообщения об ошибках должны выводится на консоль.
5. Программа не должна «вылетать» с исключениями (как стандартными, так и добавленными).

Модификации
 * *Базовая*
    * Класс `ExpressionParser` должен реализовывать интерфейс
        [Parser](Java/Exceptions/expression/exceptions/Parser.java)
    * Классы `CheckedAdd`, `CheckedSubtract`, `CheckedMultiply`,
        `CheckedDivide` и `CheckedNegate` должны реализовывать интерфейс
        [TripleExpression](Java/Exceptions/expression/TripleExpression.java)
    * Нельзя использовать типы `long` и `double`
    * Нельзя использовать методы классов `Math` и `StrictMath`
 * *Простая*
    * Дополнительно реализовать унарные операции:
        * `abs` — модуль числа, `abs -5` равно 5;
        * `sqrt` — квадратный корень, `sqrt 24` равно 4.
 * *Сложная*
    * Реализовать операции простой модификации.
    * Дополнительно реализовать бинарные операции (минимальный приоритет):
        * `min` — минимум, `2 min 3` равно 2;
        * `max` — максимум, `2 max 3` равно 3.


### Домашнее задание 11. Разбор выражений (Exception Parser)
----

1. Доработайте предыдущее домашнее задание, так что бы выражение строилось по записи вида:

                x * (x - 2)*x + 1
            
2. В записи выражения могут встречаться: умножение `*`, деление `/`, сложение `+`, вычитание `-`, унарный минус `-`, целочисленные константы (в десятичной системе счисления, которые помещаются в 32-битный знаковый целочисленный тип), круглые скобки, переменные (`x`) и произвольное число пробельных символов в любом месте (но не внутри констант).
3. Приоритет операторов, начиная с наивысшего
	* унарный минус;
	* умножение и деление;
	* сложение и вычитание.
4. Разбор выражений рекомендуется производить [методом рекурсивного спуска](https://ru.wikibooks.org/wiki/%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B2%D0%BD%D0%BE%D0%B3%D0%BE_%D1%81%D0%BF%D1%83%D1%81%D0%BA%D0%B0). Алгоритм должен работать за линейное время.

Модификации
 * *Базовая*
    * Класс `ExpressionParser` должен реализовывать интерфейс
        [Parser](Java/ExpressionParser/expression/parser/Parser.java)
    * Результат разбора должен реализовывать интерфейс
        [TripleExpression](Java/ExpressionParser/expression/TripleExpression.java)
 * *Простая*
    * Дополнительно реализовать бинарные операции:
        * `<<` — сдвиг влево, минимальный приоритет (`1 << 5 + 3` равно `1 << (5 + 3)` равно 256);
        * `>>` — сдвиг вправо, минимальный приоритет (`1024 >> 5 + 3` равно `1024 >> (5 + 3)` равно 4);
 * *Сложная*
    * Дополнительно реализовать унарные операции (приоритет как у унарного минуса):
        * Дополнительно реализовать бинарные операции:
        * `&` — побитное И, приоритет меньше чем у `+` (`6 & 1 + 2` равно `6 & (1 + 2)` равно 2);
        * `^` — побитный XOR, приоритет меньше чем у `&` (`6 ^ 1 + 2` равно `6 ^ (1 + 2)` равно 5);
        * `|` — побитное ИЛИ, приоритет меньше чем у `^` (`6 | 1 + 2` равно `6 | (1 + 2)` равно 7);
        * `~` — побитное отрицание, `~-5` равно 4;
        * `count` — число установленных битов, `count -5` равно 31.

### Домашнее задание 10. Вычисление выражений (Expressions)
----

1. Разработайте классы Const, Variable, Add, Subtract, Multiply, Divide для вычисления выражений с одной переменной.
2. Классы должны позволять составлять выражения вида
```             
	new Subtract(
    		new Multiply(
        		new Const(2),
        		new Variable("x")
    		),
    		new Const(3)
	).evaluate(5)
```

3. При вычислении такого выражения вместо каждой переменной подставляется значение, переданное в качестве параметра методу evaluate (на данном этапе имена переменных игнорируются). Таким образом, результатом вычисления приведенного примера должно стать число 7.
4. Для тестирования программы должен быть создан класс Main, который вычисляет значение выражения x2−2x+1, для x, заданного в командной строке.
5. При выполнение задания следует обратить внимание на:
	* Выделение общего интерфейса создаваемых классов.
	* Выделение абстрактного базового класса для бинарных операций.
	
Модификации
 * *Базовая*
    * Реализовать интерфейс [Expression](Java/SimpleExpression/expression/Expression.java)
 * *Простая*
    * Реализовать интерфейс [DoubleExpression](Java/SimpleExpression/expression/DoubleExpression.java)


### Домашнее задание 9. Очередь на связном списке (Linked/Array Queue)
----

1. Определите интерфейс очереди Queue и опишите его контракт.
2. Реализуйте класс LinkedQueue — очередь на связном списке.
3. Выделите общие части классов LinkedQueue и ArrayQueue в базовый класс AbstractQueue.

Модификации
 * *Простая*
    * Добавить в интерфейс очереди и реализовать метод
      `toArray`, возвращающий массив,
      содержащий элементы, лежащие в очереди в порядке
      от головы к хвосту
    * Исходная очередь должна оставаться неизменной
    * Дублирования кода быть не должно
 * *Сложная*
    * Добавить в интерфейс очереди и реализовать методы
        * `filter(predicate)` – создать очередь, содержащую элементы, удовлетворяющие
            [предикату](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html)
        * `map(function)` – создать очередь, содержащую результаты применения
            [функции](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html)
    * Исходная очередь должна остаться неизменной
    * Тип возвращаемой очереди должен соответствовать типу исходной очереди
    * Взаимный порядок элементов должен сохраняться
    * Дублирования кода быть не должно

### Домашнее задание 8. Очередь на массиве (ArrayQueue)
----

1. Найдите инвариант структуры данных «[очередь](https://ru.wikipedia.org/wiki/%D0%9E%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))». Определите функции, которые необходимы для реализации очереди. Найдите их пред- и постусловия.
2. Реализуйте классы, представляющие циклическую очередь с применением массива.
	* Класс ArrayQueueModule должен реализовывать один экземпляр очереди с использованием переменных класса.
	* Класс ArrayQueueADT должен реализовывать очередь в виде абстрактного типа данных (с явной передачей ссылки на экземпляр очереди).
	* Класс ArrayQueue должен реализовывать очередь в виде класса (с неявной передачей ссылки на экземпляр очереди).
3. Должны быть реализованы следующие функции (процедуры) / методы:
	* enqueue – добавить элемент в очередь;
	* element – первый элемент в очереди;
	* dequeue – удалить и вернуть первый элемент в очереди;
    * size – текущий размер очереди;
    * isEmpty – является ли очередь пустой;
    * clear – удалить все элементы из очереди.
3. Инвариант, пред- и постусловия записываются в исходном коде в виде комментариев.
4. Обратите внимание на инкапсуляцию данных и кода во всех трех реализациях.
5. Напишите тесты реализованным классам.

Модификации
 * *Базовая*
    * Классы должны находиться в пакете `queue`
 * *Простая*
    * Реализовать метод `toArray`, возвращающий массив,
      содержащий элементы, лежащие в очереди в порядке
      от головы к хвосту.
    * Исходная очередь должна остаться неизменной
    * Дублирования кода быть не должно
 * *Сложная*
    * Реализовать методы
        * `push` – добавить элемент в начало очереди
        * `peek` – вернуть последний элемент в очереди
        * `remove` – вернуть и удалить последний элемент из очереди


### Домашнее задание 7. Бинарный поиск (Binary Search)
----

1. Реализуйте итеративный и рекурсивный варианты бинарного поиска в массиве.
2. На вход подается целое число x и массив целых чисел a, отсортированный по невозрастанию. Требуется найти минимальное значение индекса i, при котором a[i] <= x.
3. Для функций бинарного поиска и вспомогательных функций должны быть указаны, пред- и постусловия. Для реализаций методов должны быть приведены доказательства соблюдения контрактов в терминах троек Хоара.
4. Интерфейс программы.
   * Имя основного класса — `BinarySearch`.
   * Первый аргумент командной строки — число x.
   * Последующие аргументы командной строки — элементы массива a.
5. Пример запуска: `java BinarySearch 3 5 4 3 2 1`. Ожидаемый результат: 2.

Модификации
 * *Базовая*
    * Класс `BinarySearch` должен находиться в пакете `search`
 * *Простая*
    * Если в массиве `a` отсутствует элемент, равный `x`, то требуется
      вывести индекс вставки в формате, определенном в
      [`Arrays.binarySearch`](http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#binarySearch-int:A-int-).
    * Класс должен иметь имя `BinarySearchMissing`

### Домашнее задание 6. Подсчет слов++ (WordStat++)
----

Модификация
 * *LineIndex*
    * В выходном файле слова должны быть упорядочены в лексикографическом порядке
    * Вместо номеров вхождений во всем файле надо указывать
      `<номер строки>:<номер в строке>`
    * Класс должен иметь имя `WordStatLineIndex`



1. Разработайте класс `WordStatIndex`, который будет подсчитывать статистику встречаемости слов во входном файле.
2. Словом называется неперывная последовательность букв, апострофов и тире (Unicode category Punctuation, Dash). Для подсчета статистики, слова приводятся к нижнему регистру.
3. Выходной файл должен содержать все различные слова, встречающиеся во входном файле, в порядке их появения. Для каждого слова должна быть выведена одна строка, содежащая слово, число его вхождений во входной файл и номера вхождений этого слова среди всех слов во входном файле.
4. Имена входного и выходного файла задаются в качестве аргументов командной строки. Кодировка файлов: UTF-8.
5. Программа должна работать за линейное от размера входного файлам время.
6. Для реализации программы используйте `Collections Framework`.
7. Примеры работы программы:
``` 
Входной файл:
    To be, or not to be, that is the question:
Выходной файл:
    to 2 1 5
    be 2 2 6
    or 1 3
    not 1 4
    that 1 7
    is 1 8
    the 1 9
    question 1 10
Входной файл:
    Monday's child is fair of face.
    Tuesday's child is full of grace.
Выходной файл:
    monday's 1 1
    child 2 2 8
    is 2 3 9
    fair 1 4
    of 2 5 11
    face 1 6
    tuesday's 1 7
    full 1 10
    grace 1 12
Входной файл:
    Шалтай-Болтай
    Сидел на стене.
    Шалтай-Болтай
    Свалился во сне.
Выходной файл:
    шалтай-болтай 2 1 5
    сидел 1 2
    на 1 3
    стене 1 4
    свалился 1 6
    во 1 7
    сне 1 8
```


### Домашнее задание 5. Быстрый реверс (Fast Reverse)
----

* Написать `Scanner` используя побайтовое считывание, то есть нельзя использовать `BufferedReader` и аналоги!
* Запрешено использовать регулярные выражения, функцию `split`, класс `StringTokenizer` и аналоги.

Модификация
 * *Сумма*
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите сумму чисел в его столбце и строке.
    * Класс должен иметь имя `ReverseSum`


1. Реализуйте свой аналог класса `Scanner`. Разработайте класс Reverse, читающий числа из стандартного входа, и выводящий их на стандартный вывод в обратном порядке.
2. Примените разработанный `Scanner` для решения задания "Реверc".
3. Модифицируйте решени задания "Реверc" так, что бы оно работало за линейное время.


### Домашнее задание 4. Подсчет слов (WordStat)
----
Модификация
 * *Words*
    * В выходном файле слова должны быть упорядочены в лексикографическом порядке
    * Класс должен иметь имя `WordStatWords`

1. Разработайте класс `WordStatInput`, который будет подсчитывать статистику встречаемости слов во входном файле.
2. Словом называется неперывная последовательность букв, апострофов и тире (Unicode category Punctuation, Dash). Для подсчета статистики, слова приводятся к нижнему регистру.
3. Выходной файл должен содержать все различные слова, встречающиеся во входном файле, в порядке их появения. Для каждого слова должна быть выведена одна строка, содежащая слово и число его вхождений во входной файл.
4. Имена входного и выходного файла задаются в качестве аргументов командной строки. Кодировка файлов: UTF-8.
5. Примеры работы программы:
```
     Входной файл:
         To be, or not to be, that is the question:
     Выходной файл:
         to 2
         be 2
         or 1
         not 1
         that 1
         is 1
         the 1
         question 1
     Входной файл:
         Monday's child is fair of face.
         Tuesday's child is full of grace.
     Выходной файл:
         monday's 1
         child 2
         is 2
         fair 1
         of 2
         face 1
         tuesday's 1
         full 1
         grace 1
     Входной файл:
         Шалтай-Болтай
         Сидел на стене.
         Шалтай-Болтай
         Свалился во сне.
     Выходной файл:
         шалтай-болтай 2
         сидел 1
         на 1
         стене 1
         свалился 1
         во 1
         сне 1
```


### Домашнее задание 3. Сумма чисел в файле (SumFile)
----
Модификации
 * *Abc*
    * На вход подаются числа, представленные буквами.
      Нулю соответствует буква `a`, единице – `b` и так далее
    * Ввод регистронезависим
    * Класс должен иметь имя `SumAbcFile`
 * *Hex*
    * На вход подаются десятичные и шестнадцатеричные числа
    * Шестнадцатеричные числа имеют префикс `0x`
    * Ввод регистронезависим
    * Класс должен иметь имя `SumHexFile`

1. Разработайте класс `SumFile`, записывающий сумму чисел из входного файла в выходной файл.
2. Числа во входном файле разделены переводами строк и/или пробельными символами.
3. Имена входного и выходного файла задаются в качестве аргументов командной строки.
4. Примеры работы программы:
```
    Входной файл:
        1 2 3
    Выходной файл:
        6
    Входной файл:
        1 2 -3
    Выходной файл:
        0
    Входной файл:
        1 2
          3
    Выходной файл:
        6     
```
5. При выполнении задания можно считать что для представления входных данных и промежуточных результатов достаточен тип `int`.
6. В этом и последующих домашних заданиях, метод main не должен выбрасывать никаких исключений при любых (в том числе некорректных) входных данных.
7. В этом и последующих домашних заданиях, все ресурсы должны закрываться при любых (в том числе некорректных) входных данных.


### Домашнее задание 2. Реверс (Reverse)
----

Модификация
 * *Максимум*
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите максимум из чисел в его столбце и строке.
    * Класс должен иметь имя `ReverseMax`



1. Разработайте класс `Reverse`, читающий числа из стандартного входа, и выводящий их на стандартный вывод в обратном порядке.
2. В каждой строке входа содержится некоторое количество целых чисел (может быть 0). Числа разделены пробелами. Каждое число помещается в тип `int`.
3. Порядок строк в выходе должен быть обратным по сравнению с порядком строк во входе. Порядок чисел в каждой строки так же должен быть обратным к порядку чисел во входе.
4. Примеры работы программы:
	```
     Вход:
         1 2
         3
     Выход:
         3
         2 1
     Вход:
         1

         2 -3
     Выход:
         -3 2

         1
    ```


### Домашнее задание 1. Сумма чисел (Sum)
----

Модификация
 * *BigIntegerDigit*
    * Входные данные помещаются в тип [BigInteger](https://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html)
    * Класс должен иметь имя `SumBigInteger`
    * Числа имеют вид `[знак]цифры`


1. Разработайте класс `Sum`, который при запуске из командной строки будет складывать переданные в качестве аргументов целые числа и выводить их сумму на консоль.
2. Примеры запуска программы:
	```
	java Sum 1 2 3
		Результат: 6
	java Sum 1 2 -3
		Результат: 0
	java Sum "1 2 3"
		Результат: 6
	java Sum "1 2" " 3"
		Результат: 6
	```
	Аргументы могут содержать цифры и произвольные [пробельные символы](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isWhitespace-char-).
3. При выполнении задания можно считать что для представления входных данных и промежуточных результатов достаточен тип `int`.
4. При выполнении задания полезно ознакомиться с документацией к классам [String](http://download.oracle.com/javase/8/docs/api/java/lang/String.html) и [Integer](http://download.oracle.com/javase/8/docs/api/java/lang/Integer.html).

